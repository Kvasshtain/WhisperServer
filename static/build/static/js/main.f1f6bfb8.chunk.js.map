{"version":3,"sources":["applicationSettings.js","actions/chatSettingsActions.js","actions/messageListActions.js","reducers/index.js","reducers/messageListData.js","reducers/chatSettings.js","components/NewChatForm.js","components/MessageTimestamp.js","components/MessageFrame.js","components/NewMessageInput.js","containers/MessageList.js","components/ChatFrame.js","containers/ChatList.js","components/AuthenticationForm.js","components/RegistrationForm.js","containers/App.js","serviceWorker.js","index.js","store/configureStore.js"],"names":["serverLocation","messageSendPath","messageGetPath","submitNewChatPath","chatsListGetPath","submitUserNameAndPasswordPath","submitNewUserPath","fetchMessagesCount","CHANGE_CURRENT_USER","CHANGE_CURRENT_CHAT","REFRESH_CHATS_LIST","SET_AUTHENTICATION_RESULT","SET_LAST_ERROR","changeCurrentUser","user","type","payload","changeCurrentChat","chat","refreshChatsList","chats","setAuthenticationResult","result","setLastError","status","message","fetchChatsList","userId","dispatch","token","localStorage","fetch","method","headers","then","response","ok","json","removeItem","statusText","data","catch","error","console","log","ADD_NEW_MESSAGE","MESSAGE_WAS_RECEIVED","REFRESH_MESSAGES_LIST","addNewMessage","messageWasReceived","bool","fetchMessagesList","chatId","oldestMessageTime","combineReducers","messages","state","action","concat","wasMessageReceived","currentUser","currentChat","chatsList","isUserAuthenticated","lastError","NewChatForm","name","users","onSubmit","event","preventDefault","props","onSubmitNewChat","currentUserId","setState","updateChatNameValue","eventArg","target","value","this","placeholder","onChange","React","Component","MessageTimestamp","date","Date","time","hours","getHours","minutes","getMinutes","day","getDate","month","getMonth","year","getFullYear","MessageFrame","authorName","authorEmail","text","NewMessageInput","newMessage","onSubmitNewMessage","updateInputValue","MessageList","componentDidMount","_id","getTime","length","scrollDownIfEnabled","enableScrollDown","scrollDown","current","messageListRef","scrollTop","scrollHeight","componentDidUpdate","messagesLength","previousMessagesLength","renderMessageList","map","item","index","key","onDownClick","onScroll","sendNewMessage","createRef","Fragment","onClick","ref","className","connect","ChatFrame","onSelectChat","renderUsersList","ChatList","renderChatList","AuthenticationForm","email","password","updateUserEmailValue","updateUserPasswordValue","RegistrationForm","updateUserNameValue","App","createNewChat","renderChatListNewChatForm","renderMessageListNewMessageInput","submitUserNameAndPassword","submitNewUser","renderMainContent","chatName","usersIds","newChatData","body","JSON","stringify","getState","userEmail","userPassword","userAuthenticationData","setItem","userName","userRegistrationData","Boolean","window","location","hostname","match","store","createStore","rootReducer","applyMiddleware","thunk","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f1f6bfb8.chunk.js","sourcesContent":["export const serverLocation = 'http://localhost:4000/'\n\nexport const messageSendPath = 'messages/new/'\nexport const messageGetPath = 'messages/listRequest/'\nexport const submitNewChatPath = 'chats/new/'\nexport const chatsListGetPath = 'chats/listRequest/'\nexport const submitUserNameAndPasswordPath = 'users/login/'\nexport const submitNewUserPath = 'users/new/'\n\nexport const fetchMessagesCount = 3","import { serverLocation, submitNewChatPath, chatsListGetPath, submitUserNameAndPasswordPath, submitNewUserPath } from '../applicationSettings'\n\nexport const CHANGE_CURRENT_USER = 'CHANGE_CURRENT_USER'\nexport const CHANGE_CURRENT_CHAT = 'CHANGE_CURRENT_CHAT'\nexport const REFRESH_CHATS_LIST = 'REFRESH_CHATS_LIST'\nexport const SET_AUTHENTICATION_RESULT = 'SET_AUTHENTICATION_RESULT'\nexport const SET_LAST_ERROR = 'SET_LAST_ERROR'\n\nexport function changeCurrentUser(user) {\n    return {\n        type: CHANGE_CURRENT_USER,\n        payload: user\n    }\n}\n\nexport function changeCurrentChat(chat) {\n    return {\n        type: CHANGE_CURRENT_CHAT,\n        payload: chat\n    }\n}\n\nexport function refreshChatsList(chats) {\n    return {\n        type: REFRESH_CHATS_LIST,\n        payload: chats,\n    }\n}\n\nexport function setAuthenticationResult(result) {\n    return {\n        type: SET_AUTHENTICATION_RESULT,\n        payload: result,\n    }\n}\n\nexport function setLastError(status, message) {\n    return {\n        type: SET_LAST_ERROR,\n        payload: {\n            status,\n            message,\n        }\n    }\n}\n\nexport function createNewChat(name, users) {\n    return (dispatch) => {\n\n        const token = localStorage.token\n\n        if(token) {\n            let newChatData = {\n                chat: {\n                    name,\n                    users,\n                }\n            }\n    \n            fetch(serverLocation + submitNewChatPath, {\n                method: 'POST',\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${token}`,\n                },\n                body: JSON.stringify(\n                    newChatData\n                )\n            })\n                .then((response) => {\n                    \n                    if (!response.ok) {\n\n                        localStorage.removeItem('token')\n\n                        return {\n                            status: response.status,\n                            message: response.statusText,\n                        }\n                    }\n                    \n                    return response.json()\n                })\n                .then((data) => {\n    \n                    if (data.message) {\n                        dispatch(setLastError(data.status, data.message))\n                    } else {\n                        let { _id, name, users } = data.chat\n    \n                        dispatch(changeCurrentChat(_id, name, users))\n                        dispatch(refreshChatsList(data))\n                    }\n                })\n                .catch(function (error) {\n                    console.log('error', error)\n                })\n        }\n    }\n}\n\nexport function fetchChatsList(userId) {\n    return (dispatch) => {\n\n        const token = localStorage.token\n\n        if(token) {\n            fetch(`${serverLocation}${chatsListGetPath}?user_id=${userId}`, {\n                method: 'GET',\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${token}`,\n                }\n            })\n                .then(response => {\n\n                    if (!response.ok) {\n\n                        localStorage.removeItem('token')\n\n                        return {\n                            status: response.status,\n                            message: response.statusText,\n                        }\n                    }\n\n                    return response.json()\n                })\n                .then((data) => {\n                    if (data.message) {\n                        dispatch(setLastError(data.status, data.message))\n\n                        localStorage.removeItem('token')\n                    } else {\n                        dispatch(refreshChatsList(data))\n                    }\n                })\n                .catch(function (error) {\n                    console.log('error', error)\n                })\n        }\n    }\n}\n\nexport function submitUserNameAndPassword(email, password) {\n    return (dispatch) => {\n\n        let userAuthenticationData = {\n            user: {\n                email,\n                name: '',\n                password,\n            }\n        }\n\n        fetch(serverLocation + submitUserNameAndPasswordPath, {\n            method: 'POST',\n            headers: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(\n                userAuthenticationData\n            )\n        })\n            .then((response) => {\n                \n                if (!response.ok) {\n                    return {\n                        status: response.status,\n                        message: response.statusText,\n                    }\n                }\n                \n                return response.json()\n            })\n            .then((data) => {\n\n                if (data.message) {\n                    dispatch(setLastError(data.status, data.message))\n                    dispatch(setAuthenticationResult(false))\n                } else {\n                    let { _id, token } = data.user\n\n                    localStorage.setItem('token', token)\n\n                    dispatch(changeCurrentUser(data.user))\n                    dispatch(setAuthenticationResult(true))\n                    dispatch(fetchChatsList(_id))\n                }\n            })\n            .catch(function (error) {\n                console.log('error', error)\n            })\n    }\n}\n\nexport function submitNewUser(email, name, password) {\n    return (dispatch) => {\n\n        let userRegistrationData = {\n            user: {\n                email,\n                name,\n                password,\n            }\n        }\n\n        fetch(serverLocation + submitNewUserPath, {\n            method: 'POST',\n            headers: {\n                'Accept': 'application/json',\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(\n                userRegistrationData\n            )\n        })\n            .then((response) => {\n                \n                if (!response.ok) {\n                    return {\n                        status: response.status,\n                        message: response.statusText,\n                    }\n                }\n                \n                return response.json()\n            })\n            .then((data) => {\n\n                if (data.message) {\n                    dispatch(setLastError(data.status, data.message))\n                    dispatch(setAuthenticationResult(false))\n                } else {\n                    let { _id, token } = data.user\n\n                    localStorage.setItem('token', token)\n\n                    dispatch(changeCurrentUser(data.user))\n                    dispatch(changeCurrentChat({}))\n                    dispatch(setAuthenticationResult(true))\n                    dispatch(fetchChatsList(_id))\n                }\n            })\n            .catch(function (error) {\n                console.log('error', error)\n            })\n    }\n}\n","import { serverLocation, messageSendPath, messageGetPath, fetchMessagesCount } from '../applicationSettings'\n\nimport { setLastError } from './chatSettingsActions'\n\nexport const ADD_NEW_MESSAGE = 'ADD_NEW_MESSAGE'\nexport const MESSAGE_WAS_RECEIVED = 'MESSAGE_WAS_RECEIVED'\nexport const REFRESH_MESSAGES_LIST = 'REFRESH_MESSAGES_LIST'\n\nexport function addNewMessage(message) {\n    return {\n        type: ADD_NEW_MESSAGE,\n        payload: message,\n    }\n}\n\nexport function messageWasReceived(bool) {\n    return {\n        type: MESSAGE_WAS_RECEIVED,\n        payload: bool\n    };\n}\n\nexport function refreshMessagesList(messages) {\n    return {\n        type: REFRESH_MESSAGES_LIST,\n        payload: messages\n    }\n}\n\nexport function sendNewMessage(text) {\n    return (dispatch, getState) => {\n\n        const token = localStorage.token\n\n        if(token){\n            dispatch(messageWasReceived(false))\n\n            let time = (new Date()).getTime();\n            let authorEmail = getState().currentUser.email\n            let authorName = getState().currentUser.name\n            let chatId = getState().currentChat._id\n    \n            let message = {\n                chatId,\n                time,\n                authorEmail,\n                authorName,\n                text,\n            }\n    \n            fetch(serverLocation + messageSendPath, {\n                method: 'POST',\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${token}`,\n                },\n                body: JSON.stringify(\n                    message\n                )\n            })\n                .then((response) => {\n                    \n                    if (!response.ok) {\n                        message.wasMessageReceived = false\n                        localStorage.removeItem('token')\n\n                        return {\n                            status: response.status,\n                            message: response.statusText,\n                        }\n                    }\n    \n                    return response.json()\n                })\n                .then((data) => {\n                    if (data.message) {\n                        dispatch(setLastError(data.status, data.message))\n                        message.wasMessageReceived = false\n                        dispatch(addNewMessage(message))\n                        localStorage.removeItem('token')\n                    } else {\n                        message.wasMessageReceived = true\n                        dispatch(addNewMessage(message))\n                        dispatch(messageWasReceived(true));\n                    }\n                })\n                .catch(function (error) {\n                    console.log('error', error)\n                })\n        }\n    };\n}\n\nexport function fetchMessagesList(chatId, oldestMessageTime) {\n    return (dispatch) => {\n\n        const token = localStorage.token\n\n        if(token){\n            fetch(`${serverLocation}${messageGetPath}?chat_id=${chatId}&oldest_message_time=${oldestMessageTime}&fetch_messages_count=${fetchMessagesCount}`, {\n                method: 'GET',\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${token}`,\n                }\n            })\n                .then(response => {\n\n                    if (!response.ok) {\n                        localStorage.removeItem('token')\n\n                        return {\n                            status: response.status,\n                            message: response.statusText,\n                        }\n                    }\n\n                    return response.json()\n                })\n                .then((data) => {\n\n                    if (data.message) {\n                        dispatch(setLastError(data.status, data.message))\n                        localStorage.removeItem('token')\n                    } else {\n                        dispatch(refreshMessagesList(data))\n                    }\n                })\n                .catch(function (error) {\n                    console.log('error', error)\n                })\n        }\n    }\n}","import { combineReducers } from 'redux'\nimport { messages, wasMessageReceived } from './messageListData'\nimport { currentUser, currentChat, chatsList, isUserAuthenticated, lastError } from './chatSettings'\n\nexport default combineReducers({\n    messages,\n    wasMessageReceived,\n    currentUser,\n    currentChat,\n    chatsList,\n    isUserAuthenticated,\n    lastError,\n})","import { ADD_NEW_MESSAGE, MESSAGE_WAS_RECEIVED, REFRESH_MESSAGES_LIST } from '../actions/messageListActions'\n\nexport function messages(state = [], action) {\n    switch (action.type) {\n        case ADD_NEW_MESSAGE:\n            return state.concat(action.payload)\n        case REFRESH_MESSAGES_LIST:\n            return action.payload\n        default:\n            return state\n    }\n}\n\nexport function wasMessageReceived(state = true, action) {\n    switch (action.type) {\n        case MESSAGE_WAS_RECEIVED:\n            return action.payload\n        default:\n            return state\n    }\n}","import { \n    CHANGE_CURRENT_USER, \n    CHANGE_CURRENT_CHAT, \n    REFRESH_CHATS_LIST, \n    SET_AUTHENTICATION_RESULT, \n    SET_LAST_ERROR\n} from '../actions/chatSettingsActions'\n\nexport function currentUser(state = {}, action) {\n    switch (action.type) {\n        case CHANGE_CURRENT_USER:\n            return action.payload\n        default:\n            return state\n    }\n}\n\nexport function currentChat(state = {}, action) {\n    switch (action.type) {\n        case CHANGE_CURRENT_CHAT:\n            return action.payload\n        default:\n            return state\n    }\n}\n\nexport function chatsList(state = [], action) {\n    switch (action.type) {\n        case REFRESH_CHATS_LIST:\n            return action.payload\n        default:\n            return state\n    }\n}\n\nexport function isUserAuthenticated(state = false, action) {\n    switch (action.type) {\n        case SET_AUTHENTICATION_RESULT:\n            return action.payload\n        default:\n            return state\n    }\n}\n\nexport function lastError(state = {}, action) {\n    switch (action.type) {\n        case SET_LAST_ERROR:\n            return action.payload\n        default:\n            return state\n    }\n}","import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass NewChatForm extends React.Component {\n\n    state = {\n        name: '',\n        users: [],\n    }\n\n    onSubmit = (event) => {\n        event.preventDefault()\n\n        this.props.onSubmitNewChat(this.state.name, [this.props.currentUserId])\n\n        this.setState({\n            name: '',\n            users: [],\n        })\n    }\n\n    updateChatNameValue = (eventArg) => {\n        this.setState({\n            name: eventArg.target.value\n        })\n    }\n\n    render() {\n        return (\n            <form onSubmit={this.onSubmit}>\n                <h1>Create new chat</h1>\n                <input\n                    name = 'chatName'\n                    placeholder = 'chat name'\n                    type = 'text'\n                    value = { this.state.name }\n                    onChange = { this.updateChatNameValue }\n                />\n                <button type = \"submit\">\n                    Create\n                </button>\n            </form>\n        )\n    }\n}\n\nNewChatForm.propTypes = {\n    currentUserId: PropTypes.string.isRequired,\n    onSubmitNewChat: PropTypes.func.isRequired,\n}\n\nexport { NewChatForm }","import React from 'react'\nimport PropTypes from 'prop-types'\n\nfunction MessageTimestamp(props) {\n\n    let date = new Date(props.time)\n    let hours = date.getHours()\n    let minutes = date.getMinutes()\n    let day = date.getDate()\n    let month = date.getMonth() + 1\n    let year = date.getFullYear()\n\n    return (\n        <div>\n            <p>{hours}:{minutes} {day}.{month}.{year}</p>\n        </div>\n    )\n}\n\nMessageTimestamp.propTypes = {\n    time: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired\n}\n\nexport { MessageTimestamp }","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { MessageTimestamp } from './MessageTimestamp'\n\nfunction MessageFrame(props) {\n\n    let message = props.message\n\n    return (\n        <div>\n            <div>\n                <p>{ message.authorName }</p>\n            </div>\n            <div>\n                <p>{ message.authorEmail }</p>\n            </div>\n            <div>\n                <p>{ message.text }</p>\n            </div>\n            <MessageTimestamp time = { message.time } />\n        </div>\n    )\n}\n\nMessageFrame.propTypes = {\n    message: PropTypes.exact({\n        _id: PropTypes.string,\n        chatId: PropTypes.string.isRequired,\n        authorName: PropTypes.string.isRequired,\n        authorEmail: PropTypes.string.isRequired,\n        time: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,\n        text: PropTypes.string.isRequired,\n        wasMessageReceived: PropTypes.bool,\n    })\n}\n\nexport { MessageFrame }","import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass NewMessageInput extends React.Component {\n\n    state = {\n        newMessage: ''\n    }\n\n    onSubmit = (event) => {\n        event.preventDefault()\n        \n        this.props.onSubmitNewMessage(this.state.newMessage)\n\n        this.setState({\n            newMessage: ''\n        })\n    }\n\n    updateInputValue = (eventArg) => {\n        this.setState({\n            newMessage: eventArg.target.value\n        })\n    }\n\n    render() {\n        return (\n            <form onSubmit = { this.onSubmit }>\n                <h1>Send new message</h1>\n                <input\n                    name = 'userMessage'\n                    placeholder = 'message text'\n                    type = 'text'\n                    value = { this.state.newMessage }\n                    onChange = { this.updateInputValue }\n                />\n                <button type = 'submit'>\n                    Send message\n                </button>\n            </form>\n        )\n    }\n}\n\nNewMessageInput.propTypes = {\n    onSubmitNewMessage: PropTypes.func.isRequired\n}\n\nexport { NewMessageInput }","import React from 'react'\nimport { connect } from 'react-redux';\nimport PropTypes from 'prop-types'\nimport { fetchMessagesList } from '../actions/messageListActions';\nimport { MessageFrame } from '../components/MessageFrame'\nimport { NewMessageInput } from '../components/NewMessageInput'\n\nclass MessageList extends React.Component {\n\n    constructor(props) {\n        super(props)\n        this.messageListRef = React.createRef()\n        this.state = {\n            enableScrollDown: true,\n            scrollTop: 0,\n            previousMessagesLength: 0,\n        }\n    }\n\n    componentDidMount = () => {\n\n        let currentChat = this.props.currentChat\n        let messages = this.props.messages\n\n        if(!currentChat || !currentChat._id) return\n        if(!messages) return\n\n        let time = (new Date()).getTime();\n\n        let oldestMessageTime = messages.length ? messages[0].time : time\n\n        this.props.fetchMessagesList(currentChat._id, oldestMessageTime)\n    }\n\n    scrollDownIfEnabled = () => {\n        if (this.state.enableScrollDown) {\n\n            this.setState({\n                enableScrollDown: false,\n            })\n\n            this.scrollDown()\n        }\n    }\n\n    scrollDown = () => {\n        const { current } = this.messageListRef\n\n        current.scrollTop = current.scrollHeight\n    }\n\n    componentDidUpdate = () => {\n        const { messages } = this.props;\n        \n        if (!messages) return\n        \n        let messagesLength = messages.length\n        let previousMessagesLength = this.state.previousMessagesLength\n        \n        if (messagesLength === previousMessagesLength) return\n\n        this.setState({\n            previousMessagesLength: messagesLength,\n        })\n\n        this.scrollDownIfEnabled()\n    }\n\n    renderMessageList = () => {\n        const { messages } = this.props;\n        let messagesLength = messages.length\n\n        if (messages && messagesLength) {\n            return messages.map(function (item, index) {\n                return (\n                    <MessageFrame key = { index } message = { item } />\n                    )\n                })\n        }\n    }\n\n    onDownClick = () => {\n        this.scrollDown()\n    }\n\n    onScroll = () => {\n\n    }\n\n    sendNewMessage = (newMessage) => {\n        this.props.sendNewMessage(newMessage)\n        \n        this.setState({\n            enableScrollDown: true,\n        })\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <button onClick = { this.onDownClick}>\n                    Scroll down\n                </button>\n                <div ref={this.messageListRef} className=\"messageList\" onScroll = { this.onScroll }>\n                    {this.renderMessageList()}\n                </div>\n                <NewMessageInput\n                    onSubmitNewMessage = { this.sendNewMessage }\n                />\n            </React.Fragment>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        messages: state.messages,\n        currentChat: state.currentChat,\n    }\n}\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        fetchMessagesList: (chatId, oldestMessageTime) => dispatch(fetchMessagesList(chatId, oldestMessageTime)),\n    }\n}\n\nMessageList.propTypes = {\n    messages: PropTypes.arrayOf(PropTypes.shape({\n        message: PropTypes.exact({\n            chatId: PropTypes.number.isRequired,\n            authorName: PropTypes.string.isRequired,\n            authorEmail: PropTypes.string.isRequired,\n            time: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,\n            text: PropTypes.string.isRequired,\n            wasMessageReceived: PropTypes.bool,\n        })\n    })\n    )\n}\n\nexport { MessageList }\nexport default connect(mapStateToProps, mapDispatchToProps)(MessageList);","import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass ChatFrame extends React.Component {\n\n    onSelectChat = () => {\n        \n        let chat = this.props.chat\n        \n        this.props.onSelectChat(chat)\n    }\n\n    renderUsersList = (users) => {\n        \n        if (users && users.length) {\n\n            return users.map((item, index) => {\n                return (\n                    <div key = { index }>\n                        <p>{ item.name }</p>\n                    </div>  \n                )\n            })\n        }\n    }\n\n    render() {\n        let chat = this.props.chat\n\n        return (\n            <div onClick = { this.onSelectChat }>\n                <div>\n                    <p>{ chat.name }</p>\n                </div>\n                <div>\n                    <h3>Chat users:</h3><br />\n                        <div>\n                            { this.renderUsersList(chat.users) }\n                        </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nChatFrame.propTypes = {\n    chat: PropTypes.exact({\n        _id: PropTypes.string.isRequired,\n        name: PropTypes.string.isRequired,\n        users: PropTypes.arrayOf(PropTypes.exact({\n            _id: PropTypes.string.isRequired,\n            name: PropTypes.string.isRequired,\n            email: PropTypes.string.isRequired,\n        })).isRequired,\n    }),\n    onSelectChat: PropTypes.func.isRequired,\n}\n\nexport { ChatFrame }","import React from 'react'\nimport { connect } from 'react-redux';\nimport PropTypes from 'prop-types'\nimport { fetchChatsList, changeCurrentChat } from '../actions/chatSettingsActions';\nimport { ChatFrame } from '../components/ChatFrame'\n\nclass ChatList extends React.Component {\n\n    componentDidMount() {\n\n        let userId = this.props.currentUser._id\n\n        if (!userId) return\n\n        this.props.fetchChatsList(userId)\n    }\n\n    renderChatList = () => {\n        const { chatsList, changeCurrentChat } = this.props;\n\n        if (chatsList && chatsList.length) {\n            return chatsList.map(function (item) {\n                return (\n                    <ChatFrame onSelectChat = { changeCurrentChat } key = { item._id } chat = { item } />\n                )\n            })\n        }\n    }\n\n    render() {\n        return (\n            <div className = \"сhatList\">\n                {this.renderChatList()}\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        chatsList: state.chatsList,\n        currentUser: state.currentUser,\n    }\n}\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        fetchChatsList: (userId) => dispatch(fetchChatsList(userId)),\n        changeCurrentChat: (chat) => dispatch(changeCurrentChat(chat)),\n    }\n}\n\nChatList.propTypes = {\n    chatsList: PropTypes.arrayOf(PropTypes.shape({\n        chat: PropTypes.exact({\n            _id: PropTypes.string.isRequired,\n            name: PropTypes.string.isRequired,\n            users: PropTypes.arrayOf(PropTypes.shape({\n                _id: PropTypes.string.isRequired,\n                name: PropTypes.string.isRequired,\n                email: PropTypes.string.isRequired,\n            })).isRequired,\n        })\n    })),\n    changeCurrentChat: PropTypes.func.isRequired,\n}\n\nexport { ChatList }\nexport default connect(mapStateToProps, mapDispatchToProps)(ChatList);","import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass AuthenticationForm extends React.Component {\n\n    state = {\n        email: '',\n        password: ''\n    }\n\n    onSubmit = (event) => {\n        event.preventDefault()\n\n        this.props.onSubmit(this.state.email, this.state.password)\n\n        this.setState({\n            email: '',\n            password: '',\n        })\n    }\n\n    updateUserEmailValue = (eventArg) => {\n        this.setState({\n            email: eventArg.target.value\n        })\n    }\n\n    updateUserPasswordValue = (eventArg) => {\n        this.setState({\n            password: eventArg.target.value\n        })\n    }\n\n    render() {\n        return (\n            <form onSubmit={this.onSubmit}>\n                <h1>Login</h1>\n                <label>User email</label>\n                <input\n                    name='userEmail'\n                    placeholder='User email'\n                    type='text'\n                    value={this.state.email}\n                    onChange={this.updateUserEmailValue}\n                /><br />\n                <label>User password</label>\n                <input\n                    name='userPassword'\n                    placeholder='User password'\n                    type='text'\n                    value={this.state.password}\n                    onChange={this.updateUserPasswordValue}\n                /><br />\n                <button type=\"submit\">\n                    Submit\n                </button>\n            </form>\n        )\n    }\n}\n\nAuthenticationForm.propTypes = {\n    onSubmit: PropTypes.func.isRequired\n}\n\nexport { AuthenticationForm }","import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass RegistrationForm extends React.Component {\n\n    state = {\n        email: '',\n        name: '',\n        password: '',\n    }\n\n    onSubmit = (eventArg) => {\n        eventArg.preventDefault()\n\n        this.props.onSubmit(this.state.email, this.state.name, this.state.password)\n\n        this.setState({\n            email: '',\n            name: '',\n            password: '',\n        })\n    }\n\n    updateUserEmailValue = (eventArg) => {\n        this.setState({\n            email: eventArg.target.value\n        })\n    }\n\n    updateUserNameValue = (eventArg) => {\n        this.setState({\n            name: eventArg.target.value\n        })\n    }\n\n    updateUserPasswordValue = (eventArg) => {\n        this.setState({\n            password: eventArg.target.value\n        })\n    }\n\n    render() {\n        return (\n            <form onSubmit={this.onSubmit}>\n                <h1>New user registration</h1>\n                <label>User email</label>\n                <input\n                    name = \"userEmail\"\n                    placeholder = 'User email'\n                    type = 'text'\n                    value = { this.state.email }\n                    onChange = { this.updateUserEmailValue }\n                /><br />\n                <label>User name</label>\n                <input\n                    name = 'userName'\n                    placeholder = 'User name'\n                    type = 'text'\n                    value = { this.state.name }\n                    onChange = { this.updateUserNameValue }\n                /><br />\n                <label>User password</label>\n                <input\n                    name = 'userPassword'\n                    placeholder = 'User password'\n                    type = 'text'\n                    value = { this.state.password }\n                    onChange = { this.updateUserPasswordValue }\n                /><br />\n                <button type = 'submit'>\n                    Send new user registration data\n                </button>\n            </form>\n        )\n    }\n}\n\nRegistrationForm.propTypes = {\n    onSubmit: PropTypes.func.isRequired\n}\n\nexport { RegistrationForm }","import React from 'react'\nimport { NewChatForm } from '../components/NewChatForm'\nimport MessageList from './MessageList'\nimport ChatList from './ChatList'\nimport { AuthenticationForm } from '../components/AuthenticationForm'\nimport { RegistrationForm } from '../components/RegistrationForm'\nimport { connect } from 'react-redux'\nimport { sendNewMessage } from '../actions/messageListActions'\nimport { submitUserNameAndPassword, submitNewUser, createNewChat } from '../actions/chatSettingsActions'\nimport '../App.css'\n\nclass App extends React.Component {\n\n  renderChatListNewChatForm() {\n    if (this.props.currentUser._id) {\n      return (\n        <React.Fragment>\n          <ChatList />\n          <NewChatForm\n            onSubmitNewChat = { this.props.createNewChat }\n            currentUserId = { this.props.currentUser._id }\n          />\n        </React.Fragment>\n      ) \n    }\n  }\n\n  renderMessageListNewMessageInput() {\n    if (!this.props.currentUser._id) return\n    if (!this.props.currentChat._id) return\n\n    return (\n        <MessageList sendNewMessage = { this.props.sendNewMessage } />\n    )\n  }\n\n  renderMainContent() {\n    if (this.props.isUserAuthenticated) {\n      return (\n        <React.Fragment>\n          <h1>Curret user: { this.props.currentUser.name }</h1>\n          <h1>Curret chat: { this.props.currentChat.name }</h1>\n          {this.renderChatListNewChatForm()}\n          {this.renderMessageListNewMessageInput()}\n        </React.Fragment>\n      )\n    }\n\n    return (\n      <AuthenticationForm\n        onSubmit = { this.props.submitUserNameAndPassword }\n      />\n    )\n  }\n\n  render() {\n\n    return (\n      <React.Fragment>\n        <RegistrationForm \n          onSubmit = { this.props.submitNewUser }\n        />\n        {this.renderMainContent()}\n      </React.Fragment>\n    )\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    currentUser: state.currentUser,\n    currentChat: state.currentChat,\n    wasMessageReceived: state.wasMessageReceived,\n    isUserAuthenticated: state.isUserAuthenticated,\n  }\n}\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    createNewChat: (chatName, usersIds) => dispatch(createNewChat(chatName, usersIds)),\n    sendNewMessage: (message) => dispatch(sendNewMessage(message)),\n    submitUserNameAndPassword: (userEmail, userPassword) => dispatch(submitUserNameAndPassword(userEmail, userPassword)),\n    submitNewUser: (userEmail, userName, userPassword) => dispatch(submitNewUser(userEmail, userName, userPassword)),\n  }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport configureStore from './store/configureStore';\nimport './index.css';\nimport App from './containers/App';\nimport * as serviceWorker from './serviceWorker';\n\nconst store = configureStore()\n\nReactDOM.render(\n    <Provider store = {store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers';\n\nexport default function configureStore(initialState) {\n\n    return createStore(\n        rootReducer,\n        applyMiddleware(thunk)\n    );\n}"],"sourceRoot":""}